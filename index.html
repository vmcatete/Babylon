<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/gltf_validator.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        this.currentPlayer;
this.mainScene;
this.gameGui;
this.rollMessage;
this.playerList = [];
var playerPoints = [];
var playerLabels = [];
var createScene = () => {

    // This creates a basic Babylon Scene object (non-mesh)
    this.mainScene = new BABYLON.Scene(engine);
    this.mainScene.clearColor =  new BABYLON.Color3(0.5, 0.8, 0.8);

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), this.mainScene);

    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), this.mainScene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    generateTerrain(this.mainScene);

    this.playerList = loadCharacters(this.mainScene);
    setTimeout(function() {    
        this.currentPlayer=this.playerList[0];    
    }, 2500);

    playerPoints = [0,0,0,0];
    playerLabels = [];
    loadGUI(this.mainScene);
    return this.mainScene;

};    

const triggerEvent = () => {
    console.log("NO ISSUE HERE :)");
  
    this.gameGui.removeControl(this.rollMessage);
    updatePlayerScore(this.playerList.indexOf(this.currentPlayer), Math.floor(Math.random()*100) % 10 +1);
    nextPlayer();

    console.log("NO ISSUE HERE :)");
}


const animateMovement = (scene, roll) => {
    var frameRate = 30;
    var startingPos = this.currentPlayer.position.x;
    var startingPosZ = this.currentPlayer.position.z;
    var deltaX = 0, deltaZ = 0;
    if(this.currentPlayer.position.z == 3.5 && this.currentPlayer.position.x != 3.5)
    {
        if(startingPos+roll > 3.5){
            deltaX = 3.5 - startingPos;
            deltaZ = -1 * (roll-deltaX);
        } else{
            deltaX = roll;
        }
    } else if(this.currentPlayer.position.x == 3.5 && this.currentPlayer.position.z != -3.5)
    {
        if(startingPosZ-roll < -3.5){
            deltaZ = -3.5 - startingPosZ;
            deltaX = -1 * (roll+deltaZ);
        } else{
            deltaZ = -1 * roll;
        }
    } else if (this.currentPlayer.position.z == -3.5 && this.currentPlayer.position.x != -3.5)
    {
        if (startingPos-roll < -3.5)  
        {                
            deltaX = -3.5-startingPos;
            deltaZ = roll- Math.abs(deltaX);
        } else 
        {
            deltaX = -1 * roll;                     
        }
    } else if (this.currentPlayer.position.x == -3.5 && this.currentPlayer.position.z != 3.5)
    {
        if (startingPosZ+roll > 3.5)   
        {                
            deltaZ = 3.5 - startingPosZ;
            deltaX = roll - Math.abs(deltaZ);
        } else 
        {
            deltaZ =  roll; 
        }
    } 
    var xSlide = new BABYLON.Animation("xSlide", "position.x", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    var keyFrames = []; 
    keyFrames.push({
        frame: 0,
        value: startingPos 
    });
    keyFrames.push({
        frame: .66 * frameRate,
        value: startingPos + (.3 * deltaX ) 
    });
    keyFrames.push({
        frame: 1.33 * frameRate,
        value: startingPos + (.6 * deltaX ) 
    });
    keyFrames.push({
        frame: 2 * frameRate,
        value: startingPos + (1 * deltaX )
    });
    xSlide.setKeys(keyFrames);

    var zSlide = new BABYLON.Animation("zSlide", "position.z", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    var keyFramesZ = []; 
    keyFramesZ.push({
        frame: 0,
        value: startingPosZ 
    });
    keyFramesZ.push({
        frame: .66 * frameRate,
        value: startingPosZ + (.3 * deltaZ ) 
    });
    keyFramesZ.push({
        frame: 1.33 * frameRate,
        value: startingPosZ + (.6 * deltaZ ) 
    });
    keyFramesZ.push({
        frame: 2 * frameRate,
        value: startingPosZ + (1 * deltaZ )
    });
    zSlide.setKeys(keyFramesZ);

    //Right || Left 
    if (Math.abs(this.currentPlayer.position.x) == 3.5 && Math.abs(this.currentPlayer.position.z)!=3.5)
    {
        this.mainScene.beginDirectAnimation(this.currentPlayer, [zSlide], 0, 2 * frameRate, false, 1,
            () => {
                this.mainScene.beginDirectAnimation(this.currentPlayer, [xSlide], 0, 2 * frameRate, false, triggerEvent());
    });
    } //Front || Back 
    if (Math.abs(this.currentPlayer.position.z) == 3.5 && Math.abs(this.currentPlayer.position.x)!=3.5)
    {
        this.mainScene.beginDirectAnimation(this.currentPlayer, [xSlide], 0, 2 * frameRate, false, 1, () => {
        this.mainScene.beginDirectAnimation(this.currentPlayer, [zSlide], 0, 2 * frameRate, false,  triggerEvent() );
    });
    } //FL || BR
    if (this.currentPlayer.position.x == this.currentPlayer.position.z)
    {  
        this.mainScene.beginDirectAnimation(this.currentPlayer, [zSlide], 0, 2 * frameRate, false,  triggerEvent()); 
    } // FR || BL
    if (this.currentPlayer.position.x == (this.currentPlayer.position.z * -1))
    {
        this.mainScene.beginDirectAnimation(this.currentPlayer, [xSlide], 0, 2 * frameRate, false,  triggerEvent());
    }
}

const loadGUI = (scene) => {
    this.gameGui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    this.gameGui.idealWidth = 600;

    var createPlayerBadge = function(bkgrName, lab, icon, vert, horz) {
        
        var panel = new BABYLON.GUI.StackPanel();
        panel.horizontalAlignment = horz;
        panel.verticalAlignment = vert;
        panel.isVertical = false;   
        panel.left="5px";
        this.gameGui.addControl(panel);   

        var image1 = new BABYLON.GUI.Image("", "https://raw.githubusercontent.com/vmcatete/babylon/master/" +icon);
        image1.width = "40px";
        image1.height = "40px";
        image1.left = "5px";
        image1.verticalAlignment = vert;
        image1.horizontalAlignment = horz;
        panel.addControl(image1); 

        var rect1 = new BABYLON.GUI.Rectangle();
        rect1.width = "100px";
        rect1.height = "40px";
        rect1.cornerRadius = 20;
        rect1.color = "White";
        rect1.thickness = 4;
        rect1.horizontalAlignment = horz;
        rect1.verticalAlignment = vert;
        rect1.background = bkgrName;
        rect1.paddingLeft = "5px";
        panel.addControl(rect1);  

        var label1 = new BABYLON.GUI.TextBlock();
        label1.text = lab;
        rect1.addControl(label1);
        return label1;
    }

    playerLabels[0] = createPlayerBadge("green", "Points: 0", "Peach_face.png", BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP, BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT);
    playerLabels[1] = createPlayerBadge("blue", "Points: 0", "Mario_face.png", BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP, BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT);
    playerLabels[2] = createPlayerBadge("gray", "Points: 0", "Luigi_face.png", BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM, BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT);
    playerLabels[3] = createPlayerBadge("red", "Points: 0" , "Toad_face.png", BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM, BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT);

    var diceButton = BABYLON.GUI.Button.CreateSimpleButton("but1", "Roll!");
    diceButton.width = "50px"
    diceButton.height = "50px";
    diceButton.color = "white";
    diceButton.thickness = 4;
    diceButton.cornerRadius = 10;
    diceButton.background = "gold";
    diceButton.onPointerUpObservable.add(() => {
        var roll = Math.floor(Math.random()*100) % 6 +1 ;                
        this.rollMessage = createRollSplash(roll);
        this.gameGui.addControl(this.rollMessage);  
        animateMovement(this.mainScene, roll);                      
    });
    this.gameGui.addControl(diceButton);    
}

const createRollSplash = (move) => {    
    var rect1 = new BABYLON.GUI.Rectangle();
    rect1.width = "200px";
    rect1.height = "100px";
    rect1.cornerRadius = 20;
    rect1.color = "White";
    rect1.thickness = 4;
    rect1.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
    rect1.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
    rect1.background = "gold";
    rect1.paddingLeft = "5px";

    var label1 = new BABYLON.GUI.TextBlock();
    label1.text = "You rolled a " + move +"!";
    rect1.addControl(label1); 
    return rect1;
}

const nextPlayer = () => {
    this.currentPlayer = this.playerList.indexOf(this.currentPlayer)===3? this.playerList[0] : this.playerList[this.playerList.indexOf(this.currentPlayer)+1];
}

const updatePlayerScore = (playerNum, points) => {
    playerPoints[playerNum] += points;
    playerLabels[playerNum].text = "Points: " +  playerPoints[playerNum].toString(); 
}

const generateTerrain = (scene) => {
//Set Parameters for gameboard
    var xmin = -5;
    var zmin = -5;
    var xmax =  5;
    var zmax =  5;
    var precision = {
        "w" : 1,
        "h" : 1
    };
    var subdivisions = {
        'h' : 10,
        'w' : 10
    };
    // Create the Tiled Ground
    var tiledGround = new BABYLON.Mesh.CreateTiledGround("Tiled Ground", xmin, zmin, xmax, zmax, subdivisions, precision, this.mainScene);

    // Create differents materials
    var groundMaterial = new BABYLON.StandardMaterial("Green", this.mainScene);
    groundMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
    var darkMaterial = new BABYLON.StandardMaterial("Dirt", this.mainScene);
    darkMaterial.diffuseColor = new BABYLON.Color3(1, .90, .65);
    var lightMaterial = new BABYLON.StandardMaterial("LightDirt", this.mainScene);
    lightMaterial.diffuseColor = new BABYLON.Color3(.94, .85, .64);

    // Create Multi Material
    var multimat = new BABYLON.MultiMaterial("multi", this.mainScene);  
    multimat.subMaterials.push(darkMaterial);
    multimat.subMaterials.push(lightMaterial);
    multimat.subMaterials.push(groundMaterial);

    tiledGround.material = multimat;

    // Needed variables to set subMeshes
    var verticesCount = tiledGround.getTotalVertices();
    var tileIndicesLength = tiledGround.getIndices().length / (subdivisions.w * subdivisions.h);

    // Set subMeshes of the tiled ground
    tiledGround.subMeshes = [];
    var base = 0;
    for (var row = 0; row < subdivisions.h; row++) {
        for (var col = 0; col < subdivisions.w; col++) {
            if((row==1 && col > 0 && col < 9) || (row>1 && row <9 && (col == 1 || col== 8)) || (row==8 && col > 0 && col < 9))
            {
                tiledGround.subMeshes.push(new BABYLON.SubMesh(row%2 ^ col%2, 0, verticesCount, base , tileIndicesLength, tiledGround));
                base += tileIndicesLength;
            } else {
                tiledGround.subMeshes.push(new BABYLON.SubMesh(2, 0, verticesCount, base , tileIndicesLength, tiledGround));
                base += tileIndicesLength;
            }
        }
    }
}

const loadCharacters = (scene, players = []) => {
    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/vmcatete/babylon/master/", "Peach.babylon", this.mainScene, function(newMeshes) {
        players[0] = newMeshes[0];
        players[0].scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);
        players[0].position = new BABYLON.Vector3(-1.5, .4, 3.5);  
    });
    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/vmcatete/babylon/master/", "Mario.babylon", this.mainScene, function(newMeshes) {
        players[1] = newMeshes[0];
        players[1].scaling = new BABYLON.Vector3(2.5, 3, 2.5);
        players[1].position = new BABYLON.Vector3(-.5, .35, -3.5);  
    });
    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/vmcatete/babylon/master/", "Luigi.babylon", this.mainScene, function(newMeshes) {
        players[2] = newMeshes[0];
        players[2].scaling = new BABYLON.Vector3(2.5, 3, 2.5);
        players[2].position = new BABYLON.Vector3(2.5, .35, -3.5);  
    });
    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/vmcatete/babylon/master/", "Toad.babylon", this.mainScene, function(newMeshes) {
        players[3] = newMeshes[0];
        players[3].scaling = new BABYLON.Vector3(2.5, 3, 2.5);
        players[3].position = new BABYLON.Vector3(.5, .35, -3.5);  
    });
    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/vmcatete/babylon/master/", "Yoshi.babylon", this.mainScene, function(newMeshes) {
        players[4] = newMeshes[0];
        players[4].scaling = new BABYLON.Vector3(2.5, 3, 2.5);
        players[4].position = new BABYLON.Vector3(1.5, .35, -3.5);  
    });
    return players;
}
        
        var engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        var scene = createScene();

        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
